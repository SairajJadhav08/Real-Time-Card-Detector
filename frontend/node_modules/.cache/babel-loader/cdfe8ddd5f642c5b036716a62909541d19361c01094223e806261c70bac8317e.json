{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nimport axios from 'axios';\nconst API_BASE_URL = 'http://localhost:8000';\nexport const useDetectionStats = () => {\n  _s();\n  const [stats, setStats] = useState(null);\n  const [cardFrequency, setCardFrequency] = useState([]);\n  const [timeline, setTimeline] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [lastDays, setLastDays] = useState();\n  const fetchStats = useCallback(async days => {\n    setError(null);\n    try {\n      const params = days ? {\n        days\n      } : {};\n      const response = await axios.get(`${API_BASE_URL}/api/stats`, {\n        params,\n        timeout: 10000\n      });\n      setStats(response.data);\n      setLastDays(days);\n    } catch (err) {\n      console.error('Failed to fetch detection stats:', err);\n      if (axios.isAxiosError(err)) {\n        var _err$response;\n        if (err.code === 'ECONNABORTED') {\n          setError('Request timeout. Please check your connection.');\n        } else if (((_err$response = err.response) === null || _err$response === void 0 ? void 0 : _err$response.status) === 404) {\n          setError('Stats endpoint not found. Please check the server.');\n        } else if (err.response && err.response.status >= 500) {\n          setError('Server error. Please try again later.');\n        } else {\n          var _err$response2, _err$response2$data;\n          setError(((_err$response2 = err.response) === null || _err$response2 === void 0 ? void 0 : (_err$response2$data = _err$response2.data) === null || _err$response2$data === void 0 ? void 0 : _err$response2$data.message) || 'Failed to fetch statistics');\n        }\n      } else {\n        setError('Network error. Please check your connection.');\n      }\n    }\n  }, []);\n  const fetchCardFrequency = useCallback(async days => {\n    setError(null);\n    try {\n      const params = days ? {\n        days\n      } : {};\n      const response = await axios.get(`${API_BASE_URL}/api/card-frequency`, {\n        params,\n        timeout: 10000\n      });\n      setCardFrequency(response.data.cards || []);\n    } catch (err) {\n      console.error('Failed to fetch card frequency:', err);\n      if (axios.isAxiosError(err)) {\n        if (err.code === 'ECONNABORTED') {\n          setError('Request timeout. Please check your connection.');\n        } else {\n          var _err$response3, _err$response3$data;\n          setError(((_err$response3 = err.response) === null || _err$response3 === void 0 ? void 0 : (_err$response3$data = _err$response3.data) === null || _err$response3$data === void 0 ? void 0 : _err$response3$data.message) || 'Failed to fetch card frequency');\n        }\n      } else {\n        setError('Network error. Please check your connection.');\n      }\n    }\n  }, []);\n  const fetchTimeline = useCallback(async days => {\n    setError(null);\n    try {\n      const params = days ? {\n        days\n      } : {};\n      const response = await axios.get(`${API_BASE_URL}/api/timeline`, {\n        params,\n        timeout: 10000\n      });\n      setTimeline(response.data.timeline || []);\n    } catch (err) {\n      console.error('Failed to fetch timeline:', err);\n      if (axios.isAxiosError(err)) {\n        var _err$response4;\n        if (err.code === 'ECONNABORTED') {\n          setError('Request timeout. Please check your connection.');\n        } else if (((_err$response4 = err.response) === null || _err$response4 === void 0 ? void 0 : _err$response4.status) === 404) {\n          // Timeline endpoint might not exist, ignore error\n          console.warn('Timeline endpoint not available');\n        } else {\n          var _err$response5, _err$response5$data;\n          setError(((_err$response5 = err.response) === null || _err$response5 === void 0 ? void 0 : (_err$response5$data = _err$response5.data) === null || _err$response5$data === void 0 ? void 0 : _err$response5$data.message) || 'Failed to fetch timeline');\n        }\n      } else {\n        setError('Network error. Please check your connection.');\n      }\n    }\n  }, []);\n  const refreshAll = useCallback(async days => {\n    setLoading(true);\n    setError(null);\n    try {\n      await Promise.all([fetchStats(days), fetchCardFrequency(days), fetchTimeline(days)]);\n    } catch (err) {\n      console.error('Failed to refresh all stats:', err);\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchStats, fetchCardFrequency, fetchTimeline]);\n  const getTopCards = useCallback((limit = 10) => {\n    return cardFrequency.sort((a, b) => b.count - a.count).slice(0, limit);\n  }, [cardFrequency]);\n  const getRecentActivity = useCallback((hours = 24) => {\n    const cutoffTime = new Date();\n    cutoffTime.setHours(cutoffTime.getHours() - hours);\n    return timeline.filter(item => {\n      const itemDate = new Date(item.date);\n      itemDate.setHours(item.hour);\n      return itemDate >= cutoffTime;\n    }).sort((a, b) => {\n      const dateA = new Date(a.date);\n      dateA.setHours(a.hour);\n      const dateB = new Date(b.date);\n      dateB.setHours(b.hour);\n      return dateB.getTime() - dateA.getTime();\n    });\n  }, [timeline]);\n  const calculateTrends = useCallback(() => {\n    if (!stats || !stats.daily_stats || stats.daily_stats.length < 2) {\n      return {\n        dailyTrend: 0,\n        weeklyTrend: 0,\n        confidenceTrend: 0\n      };\n    }\n    const dailyStats = stats.daily_stats.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());\n\n    // Calculate daily trend (last 2 days)\n    const lastTwo = dailyStats.slice(-2);\n    const dailyTrend = lastTwo.length === 2 ? (lastTwo[1].count - lastTwo[0].count) / Math.max(lastTwo[0].count, 1) * 100 : 0;\n\n    // Calculate weekly trend (last 7 days vs previous 7 days)\n    let weeklyTrend = 0;\n    if (dailyStats.length >= 14) {\n      const lastWeek = dailyStats.slice(-7).reduce((sum, day) => sum + day.count, 0);\n      const prevWeek = dailyStats.slice(-14, -7).reduce((sum, day) => sum + day.count, 0);\n      weeklyTrend = (lastWeek - prevWeek) / Math.max(prevWeek, 1) * 100;\n    }\n\n    // Confidence trend (simplified - based on current avg vs target)\n    const targetConfidence = 0.8;\n    const confidenceTrend = (stats.avg_confidence - targetConfidence) / targetConfidence * 100;\n    return {\n      dailyTrend: Math.round(dailyTrend * 10) / 10,\n      weeklyTrend: Math.round(weeklyTrend * 10) / 10,\n      confidenceTrend: Math.round(confidenceTrend * 10) / 10\n    };\n  }, [stats]);\n\n  // Auto-fetch initial stats\n  useEffect(() => {\n    refreshAll(30); // Default to last 30 days\n  }, [refreshAll]);\n\n  // Auto-refresh every 60 seconds\n  useEffect(() => {\n    const interval = setInterval(() => {\n      refreshAll(lastDays);\n    }, 60000);\n    return () => clearInterval(interval);\n  }, [refreshAll, lastDays]);\n  return {\n    stats,\n    cardFrequency,\n    timeline,\n    loading,\n    error,\n    fetchStats,\n    fetchCardFrequency,\n    fetchTimeline,\n    refreshAll,\n    getTopCards,\n    getRecentActivity,\n    calculateTrends\n  };\n};\n_s(useDetectionStats, \"objhnNA/QtcN9hP8e07mf4HnWMk=\");\nexport default useDetectionStats;","map":{"version":3,"names":["useState","useEffect","useCallback","axios","API_BASE_URL","useDetectionStats","_s","stats","setStats","cardFrequency","setCardFrequency","timeline","setTimeline","loading","setLoading","error","setError","lastDays","setLastDays","fetchStats","days","params","response","get","timeout","data","err","console","isAxiosError","_err$response","code","status","_err$response2","_err$response2$data","message","fetchCardFrequency","cards","_err$response3","_err$response3$data","fetchTimeline","_err$response4","warn","_err$response5","_err$response5$data","refreshAll","Promise","all","getTopCards","limit","sort","a","b","count","slice","getRecentActivity","hours","cutoffTime","Date","setHours","getHours","filter","item","itemDate","date","hour","dateA","dateB","getTime","calculateTrends","daily_stats","length","dailyTrend","weeklyTrend","confidenceTrend","dailyStats","lastTwo","Math","max","lastWeek","reduce","sum","day","prevWeek","targetConfidence","avg_confidence","round","interval","setInterval","clearInterval"],"sources":["C:/Users/Asus/OneDrive/Desktop/card/frontend/src/hooks/useDetectionStats.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport axios from 'axios';\n\ninterface DetectionStats {\n  total_detections: number;\n  unique_cards: number;\n  avg_confidence: number;\n  detection_rate: number;\n  most_detected_card: string;\n  least_detected_card: string;\n  daily_stats: Array<{\n    date: string;\n    count: number;\n  }>;\n}\n\ninterface CardFrequency {\n  card_name: string;\n  count: number;\n  percentage: number;\n  avg_confidence: number;\n}\n\ninterface CardFrequencyResponse {\n  cards: CardFrequency[];\n  total_unique_cards: number;\n  most_frequent: string;\n  least_frequent: string;\n}\n\ninterface TimelineData {\n  date: string;\n  hour: number;\n  count: number;\n  avg_confidence: number;\n}\n\ninterface UseDetectionStatsReturn {\n  stats: DetectionStats | null;\n  cardFrequency: CardFrequency[];\n  timeline: TimelineData[];\n  loading: boolean;\n  error: string | null;\n  fetchStats: (days?: number) => Promise<void>;\n  fetchCardFrequency: (days?: number) => Promise<void>;\n  fetchTimeline: (days?: number) => Promise<void>;\n  refreshAll: (days?: number) => Promise<void>;\n  getTopCards: (limit?: number) => CardFrequency[];\n  getRecentActivity: (hours?: number) => TimelineData[];\n  calculateTrends: () => {\n    dailyTrend: number;\n    weeklyTrend: number;\n    confidenceTrend: number;\n  };\n}\n\nconst API_BASE_URL = 'http://localhost:8000';\n\nexport const useDetectionStats = (): UseDetectionStatsReturn => {\n  const [stats, setStats] = useState<DetectionStats | null>(null);\n  const [cardFrequency, setCardFrequency] = useState<CardFrequency[]>([]);\n  const [timeline, setTimeline] = useState<TimelineData[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [lastDays, setLastDays] = useState<number | undefined>();\n\n  const fetchStats = useCallback(async (days?: number) => {\n    setError(null);\n    \n    try {\n      const params = days ? { days } : {};\n      const response = await axios.get<DetectionStats>(`${API_BASE_URL}/api/stats`, {\n        params,\n        timeout: 10000\n      });\n      \n      setStats(response.data);\n      setLastDays(days);\n    } catch (err) {\n      console.error('Failed to fetch detection stats:', err);\n      if (axios.isAxiosError(err)) {\n        if (err.code === 'ECONNABORTED') {\n          setError('Request timeout. Please check your connection.');\n        } else if (err.response?.status === 404) {\n          setError('Stats endpoint not found. Please check the server.');\n        } else if (err.response && err.response.status >= 500) {\n          setError('Server error. Please try again later.');\n        } else {\n          setError(err.response?.data?.message || 'Failed to fetch statistics');\n        }\n      } else {\n        setError('Network error. Please check your connection.');\n      }\n    }\n  }, []);\n\n  const fetchCardFrequency = useCallback(async (days?: number) => {\n    setError(null);\n    \n    try {\n      const params = days ? { days } : {};\n      const response = await axios.get<CardFrequencyResponse>(`${API_BASE_URL}/api/card-frequency`, {\n        params,\n        timeout: 10000\n      });\n      \n      setCardFrequency(response.data.cards || []);\n    } catch (err) {\n      console.error('Failed to fetch card frequency:', err);\n      if (axios.isAxiosError(err)) {\n        if (err.code === 'ECONNABORTED') {\n          setError('Request timeout. Please check your connection.');\n        } else {\n          setError(err.response?.data?.message || 'Failed to fetch card frequency');\n        }\n      } else {\n        setError('Network error. Please check your connection.');\n      }\n    }\n  }, []);\n\n  const fetchTimeline = useCallback(async (days?: number) => {\n    setError(null);\n    \n    try {\n      const params = days ? { days } : {};\n      const response = await axios.get<{ timeline: TimelineData[] }>(`${API_BASE_URL}/api/timeline`, {\n        params,\n        timeout: 10000\n      });\n      \n      setTimeline(response.data.timeline || []);\n    } catch (err) {\n      console.error('Failed to fetch timeline:', err);\n      if (axios.isAxiosError(err)) {\n        if (err.code === 'ECONNABORTED') {\n          setError('Request timeout. Please check your connection.');\n        } else if (err.response?.status === 404) {\n          // Timeline endpoint might not exist, ignore error\n          console.warn('Timeline endpoint not available');\n        } else {\n          setError(err.response?.data?.message || 'Failed to fetch timeline');\n        }\n      } else {\n        setError('Network error. Please check your connection.');\n      }\n    }\n  }, []);\n\n  const refreshAll = useCallback(async (days?: number) => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      await Promise.all([\n        fetchStats(days),\n        fetchCardFrequency(days),\n        fetchTimeline(days)\n      ]);\n    } catch (err) {\n      console.error('Failed to refresh all stats:', err);\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchStats, fetchCardFrequency, fetchTimeline]);\n\n  const getTopCards = useCallback((limit: number = 10): CardFrequency[] => {\n    return cardFrequency\n      .sort((a, b) => b.count - a.count)\n      .slice(0, limit);\n  }, [cardFrequency]);\n\n  const getRecentActivity = useCallback((hours: number = 24): TimelineData[] => {\n    const cutoffTime = new Date();\n    cutoffTime.setHours(cutoffTime.getHours() - hours);\n    \n    return timeline.filter(item => {\n      const itemDate = new Date(item.date);\n      itemDate.setHours(item.hour);\n      return itemDate >= cutoffTime;\n    }).sort((a, b) => {\n      const dateA = new Date(a.date);\n      dateA.setHours(a.hour);\n      const dateB = new Date(b.date);\n      dateB.setHours(b.hour);\n      return dateB.getTime() - dateA.getTime();\n    });\n  }, [timeline]);\n\n  const calculateTrends = useCallback(() => {\n    if (!stats || !stats.daily_stats || stats.daily_stats.length < 2) {\n      return {\n        dailyTrend: 0,\n        weeklyTrend: 0,\n        confidenceTrend: 0\n      };\n    }\n\n    const dailyStats = stats.daily_stats.sort((a, b) => \n      new Date(a.date).getTime() - new Date(b.date).getTime()\n    );\n\n    // Calculate daily trend (last 2 days)\n    const lastTwo = dailyStats.slice(-2);\n    const dailyTrend = lastTwo.length === 2 \n      ? ((lastTwo[1].count - lastTwo[0].count) / Math.max(lastTwo[0].count, 1)) * 100\n      : 0;\n\n    // Calculate weekly trend (last 7 days vs previous 7 days)\n    let weeklyTrend = 0;\n    if (dailyStats.length >= 14) {\n      const lastWeek = dailyStats.slice(-7).reduce((sum, day) => sum + day.count, 0);\n      const prevWeek = dailyStats.slice(-14, -7).reduce((sum, day) => sum + day.count, 0);\n      weeklyTrend = ((lastWeek - prevWeek) / Math.max(prevWeek, 1)) * 100;\n    }\n\n    // Confidence trend (simplified - based on current avg vs target)\n    const targetConfidence = 0.8;\n    const confidenceTrend = ((stats.avg_confidence - targetConfidence) / targetConfidence) * 100;\n\n    return {\n      dailyTrend: Math.round(dailyTrend * 10) / 10,\n      weeklyTrend: Math.round(weeklyTrend * 10) / 10,\n      confidenceTrend: Math.round(confidenceTrend * 10) / 10\n    };\n  }, [stats]);\n\n  // Auto-fetch initial stats\n  useEffect(() => {\n    refreshAll(30); // Default to last 30 days\n  }, [refreshAll]);\n\n  // Auto-refresh every 60 seconds\n  useEffect(() => {\n    const interval = setInterval(() => {\n      refreshAll(lastDays);\n    }, 60000);\n    \n    return () => clearInterval(interval);\n  }, [refreshAll, lastDays]);\n\n  return {\n    stats,\n    cardFrequency,\n    timeline,\n    loading,\n    error,\n    fetchStats,\n    fetchCardFrequency,\n    fetchTimeline,\n    refreshAll,\n    getTopCards,\n    getRecentActivity,\n    calculateTrends\n  };\n};\n\nexport default useDetectionStats;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}