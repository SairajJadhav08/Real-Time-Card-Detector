{"ast":null,"code":"import{useState,useEffect,useRef,useCallback}from'react';export const useWebSocket=url=>{const[isConnected,setIsConnected]=useState(false);const[detections,setDetections]=useState([]);const[lastProcessingTime,setLastProcessingTime]=useState(0);const[error,setError]=useState(null);const wsRef=useRef(null);const reconnectTimeoutRef=useRef(null);const reconnectAttempts=useRef(0);const maxReconnectAttempts=5;const reconnectDelay=3000;const connect=useCallback(()=>{var _wsRef$current;if(((_wsRef$current=wsRef.current)===null||_wsRef$current===void 0?void 0:_wsRef$current.readyState)===WebSocket.OPEN){return;}try{const ws=new WebSocket(url);wsRef.current=ws;ws.onopen=()=>{console.log('WebSocket connected');setIsConnected(true);setError(null);reconnectAttempts.current=0;};ws.onmessage=event=>{try{const message=JSON.parse(event.data);switch(message.type){case'detection':if(message.detections){setDetections(message.detections);if(message.processing_time){setLastProcessingTime(message.processing_time);}}break;case'error':console.error('WebSocket error:',message.message);setError(message.message||'Unknown error occurred');break;case'status':console.log('WebSocket status:',message.status);break;default:console.log('Unknown message type:',message.type);}}catch(err){console.error('Failed to parse WebSocket message:',err);setError('Failed to parse server response');}};ws.onclose=event=>{console.log('WebSocket disconnected:',event.code,event.reason);setIsConnected(false);wsRef.current=null;// Attempt to reconnect if not a manual disconnect\nif(event.code!==1000&&reconnectAttempts.current<maxReconnectAttempts){reconnectAttempts.current++;console.log(\"Attempting to reconnect (\".concat(reconnectAttempts.current,\"/\").concat(maxReconnectAttempts,\")...\"));reconnectTimeoutRef.current=setTimeout(()=>{connect();},reconnectDelay);}else if(reconnectAttempts.current>=maxReconnectAttempts){setError('Failed to reconnect to server. Please refresh the page.');}};ws.onerror=event=>{console.error('WebSocket error:',event);setError('Connection error occurred');};}catch(err){console.error('Failed to create WebSocket connection:',err);setError('Failed to connect to server');}},[url]);const disconnect=useCallback(()=>{if(reconnectTimeoutRef.current){clearTimeout(reconnectTimeoutRef.current);reconnectTimeoutRef.current=null;}if(wsRef.current){wsRef.current.close(1000,'Manual disconnect');wsRef.current=null;}setIsConnected(false);setDetections([]);setError(null);reconnectAttempts.current=0;},[]);const sendFrame=useCallback(imageData=>{var _wsRef$current2;if(((_wsRef$current2=wsRef.current)===null||_wsRef$current2===void 0?void 0:_wsRef$current2.readyState)===WebSocket.OPEN){try{const message={type:'frame',data:imageData};wsRef.current.send(JSON.stringify(message));}catch(err){console.error('Failed to send frame:',err);setError('Failed to send frame to server');}}else{console.warn('WebSocket is not connected');setError('Not connected to server');}},[]);const clearDetections=useCallback(()=>{setDetections([]);setError(null);},[]);// Auto-connect on mount\nuseEffect(()=>{connect();return()=>{disconnect();};},[connect,disconnect]);// Cleanup on unmount\nuseEffect(()=>{return()=>{if(reconnectTimeoutRef.current){clearTimeout(reconnectTimeoutRef.current);}};},[]);return{isConnected,detections,lastProcessingTime,error,sendFrame,connect,disconnect,clearDetections};};export default useWebSocket;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useWebSocket","url","isConnected","setIsConnected","detections","setDetections","lastProcessingTime","setLastProcessingTime","error","setError","wsRef","reconnectTimeoutRef","reconnectAttempts","maxReconnectAttempts","reconnectDelay","connect","_wsRef$current","current","readyState","WebSocket","OPEN","ws","onopen","console","log","onmessage","event","message","JSON","parse","data","type","processing_time","status","err","onclose","code","reason","concat","setTimeout","onerror","disconnect","clearTimeout","close","sendFrame","imageData","_wsRef$current2","send","stringify","warn","clearDetections"],"sources":["C:/Users/Asus/OneDrive/Desktop/card/frontend/src/hooks/useWebSocket.ts"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\n\ninterface Detection {\n  rank: string;\n  suit: string;\n  confidence: number;\n  bbox: [number, number, number, number];\n  card_name?: string;\n}\n\ninterface WebSocketMessage {\n  type: 'frame' | 'detection' | 'error' | 'status';\n  data?: any;\n  detections?: Detection[];\n  message?: string;\n  status?: string;\n  processing_time?: number;\n}\n\ninterface UseWebSocketReturn {\n  isConnected: boolean;\n  detections: Detection[];\n  lastProcessingTime: number;\n  error: string | null;\n  sendFrame: (imageData: string) => void;\n  connect: () => void;\n  disconnect: () => void;\n  clearDetections: () => void;\n}\n\nexport const useWebSocket = (url: string): UseWebSocketReturn => {\n  const [isConnected, setIsConnected] = useState(false);\n  const [detections, setDetections] = useState<Detection[]>([]);\n  const [lastProcessingTime, setLastProcessingTime] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const reconnectAttempts = useRef(0);\n  const maxReconnectAttempts = 5;\n  const reconnectDelay = 3000;\n\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return;\n    }\n\n    try {\n      const ws = new WebSocket(url);\n      wsRef.current = ws;\n\n      ws.onopen = () => {\n        console.log('WebSocket connected');\n        setIsConnected(true);\n        setError(null);\n        reconnectAttempts.current = 0;\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const message: WebSocketMessage = JSON.parse(event.data);\n          \n          switch (message.type) {\n            case 'detection':\n              if (message.detections) {\n                setDetections(message.detections);\n                if (message.processing_time) {\n                  setLastProcessingTime(message.processing_time);\n                }\n              }\n              break;\n              \n            case 'error':\n              console.error('WebSocket error:', message.message);\n              setError(message.message || 'Unknown error occurred');\n              break;\n              \n            case 'status':\n              console.log('WebSocket status:', message.status);\n              break;\n              \n            default:\n              console.log('Unknown message type:', message.type);\n          }\n        } catch (err) {\n          console.error('Failed to parse WebSocket message:', err);\n          setError('Failed to parse server response');\n        }\n      };\n\n      ws.onclose = (event) => {\n        console.log('WebSocket disconnected:', event.code, event.reason);\n        setIsConnected(false);\n        wsRef.current = null;\n        \n        // Attempt to reconnect if not a manual disconnect\n        if (event.code !== 1000 && reconnectAttempts.current < maxReconnectAttempts) {\n          reconnectAttempts.current++;\n          console.log(`Attempting to reconnect (${reconnectAttempts.current}/${maxReconnectAttempts})...`);\n          \n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, reconnectDelay);\n        } else if (reconnectAttempts.current >= maxReconnectAttempts) {\n          setError('Failed to reconnect to server. Please refresh the page.');\n        }\n      };\n\n      ws.onerror = (event) => {\n        console.error('WebSocket error:', event);\n        setError('Connection error occurred');\n      };\n    } catch (err) {\n      console.error('Failed to create WebSocket connection:', err);\n      setError('Failed to connect to server');\n    }\n  }, [url]);\n\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    \n    if (wsRef.current) {\n      wsRef.current.close(1000, 'Manual disconnect');\n      wsRef.current = null;\n    }\n    \n    setIsConnected(false);\n    setDetections([]);\n    setError(null);\n    reconnectAttempts.current = 0;\n  }, []);\n\n  const sendFrame = useCallback((imageData: string) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      try {\n        const message = {\n          type: 'frame',\n          data: imageData\n        };\n        wsRef.current.send(JSON.stringify(message));\n      } catch (err) {\n        console.error('Failed to send frame:', err);\n        setError('Failed to send frame to server');\n      }\n    } else {\n      console.warn('WebSocket is not connected');\n      setError('Not connected to server');\n    }\n  }, []);\n\n  const clearDetections = useCallback(() => {\n    setDetections([]);\n    setError(null);\n  }, []);\n\n  // Auto-connect on mount\n  useEffect(() => {\n    connect();\n    \n    return () => {\n      disconnect();\n    };\n  }, [connect, disconnect]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    isConnected,\n    detections,\n    lastProcessingTime,\n    error,\n    sendFrame,\n    connect,\n    disconnect,\n    clearDetections\n  };\n};\n\nexport default useWebSocket;"],"mappings":"AAAA,OAASA,QAAQ,CAAEC,SAAS,CAAEC,MAAM,CAAEC,WAAW,KAAQ,OAAO,CA8BhE,MAAO,MAAM,CAAAC,YAAY,CAAIC,GAAW,EAAyB,CAC/D,KAAM,CAACC,WAAW,CAAEC,cAAc,CAAC,CAAGP,QAAQ,CAAC,KAAK,CAAC,CACrD,KAAM,CAACQ,UAAU,CAAEC,aAAa,CAAC,CAAGT,QAAQ,CAAc,EAAE,CAAC,CAC7D,KAAM,CAACU,kBAAkB,CAAEC,qBAAqB,CAAC,CAAGX,QAAQ,CAAC,CAAC,CAAC,CAC/D,KAAM,CAACY,KAAK,CAAEC,QAAQ,CAAC,CAAGb,QAAQ,CAAgB,IAAI,CAAC,CACvD,KAAM,CAAAc,KAAK,CAAGZ,MAAM,CAAmB,IAAI,CAAC,CAC5C,KAAM,CAAAa,mBAAmB,CAAGb,MAAM,CAAwB,IAAI,CAAC,CAC/D,KAAM,CAAAc,iBAAiB,CAAGd,MAAM,CAAC,CAAC,CAAC,CACnC,KAAM,CAAAe,oBAAoB,CAAG,CAAC,CAC9B,KAAM,CAAAC,cAAc,CAAG,IAAI,CAE3B,KAAM,CAAAC,OAAO,CAAGhB,WAAW,CAAC,IAAM,KAAAiB,cAAA,CAChC,GAAI,EAAAA,cAAA,CAAAN,KAAK,CAACO,OAAO,UAAAD,cAAA,iBAAbA,cAAA,CAAeE,UAAU,IAAKC,SAAS,CAACC,IAAI,CAAE,CAChD,OACF,CAEA,GAAI,CACF,KAAM,CAAAC,EAAE,CAAG,GAAI,CAAAF,SAAS,CAAClB,GAAG,CAAC,CAC7BS,KAAK,CAACO,OAAO,CAAGI,EAAE,CAElBA,EAAE,CAACC,MAAM,CAAG,IAAM,CAChBC,OAAO,CAACC,GAAG,CAAC,qBAAqB,CAAC,CAClCrB,cAAc,CAAC,IAAI,CAAC,CACpBM,QAAQ,CAAC,IAAI,CAAC,CACdG,iBAAiB,CAACK,OAAO,CAAG,CAAC,CAC/B,CAAC,CAEDI,EAAE,CAACI,SAAS,CAAIC,KAAK,EAAK,CACxB,GAAI,CACF,KAAM,CAAAC,OAAyB,CAAGC,IAAI,CAACC,KAAK,CAACH,KAAK,CAACI,IAAI,CAAC,CAExD,OAAQH,OAAO,CAACI,IAAI,EAClB,IAAK,WAAW,CACd,GAAIJ,OAAO,CAACvB,UAAU,CAAE,CACtBC,aAAa,CAACsB,OAAO,CAACvB,UAAU,CAAC,CACjC,GAAIuB,OAAO,CAACK,eAAe,CAAE,CAC3BzB,qBAAqB,CAACoB,OAAO,CAACK,eAAe,CAAC,CAChD,CACF,CACA,MAEF,IAAK,OAAO,CACVT,OAAO,CAACf,KAAK,CAAC,kBAAkB,CAAEmB,OAAO,CAACA,OAAO,CAAC,CAClDlB,QAAQ,CAACkB,OAAO,CAACA,OAAO,EAAI,wBAAwB,CAAC,CACrD,MAEF,IAAK,QAAQ,CACXJ,OAAO,CAACC,GAAG,CAAC,mBAAmB,CAAEG,OAAO,CAACM,MAAM,CAAC,CAChD,MAEF,QACEV,OAAO,CAACC,GAAG,CAAC,uBAAuB,CAAEG,OAAO,CAACI,IAAI,CAAC,CACtD,CACF,CAAE,MAAOG,GAAG,CAAE,CACZX,OAAO,CAACf,KAAK,CAAC,oCAAoC,CAAE0B,GAAG,CAAC,CACxDzB,QAAQ,CAAC,iCAAiC,CAAC,CAC7C,CACF,CAAC,CAEDY,EAAE,CAACc,OAAO,CAAIT,KAAK,EAAK,CACtBH,OAAO,CAACC,GAAG,CAAC,yBAAyB,CAAEE,KAAK,CAACU,IAAI,CAAEV,KAAK,CAACW,MAAM,CAAC,CAChElC,cAAc,CAAC,KAAK,CAAC,CACrBO,KAAK,CAACO,OAAO,CAAG,IAAI,CAEpB;AACA,GAAIS,KAAK,CAACU,IAAI,GAAK,IAAI,EAAIxB,iBAAiB,CAACK,OAAO,CAAGJ,oBAAoB,CAAE,CAC3ED,iBAAiB,CAACK,OAAO,EAAE,CAC3BM,OAAO,CAACC,GAAG,6BAAAc,MAAA,CAA6B1B,iBAAiB,CAACK,OAAO,MAAAqB,MAAA,CAAIzB,oBAAoB,QAAM,CAAC,CAEhGF,mBAAmB,CAACM,OAAO,CAAGsB,UAAU,CAAC,IAAM,CAC7CxB,OAAO,CAAC,CAAC,CACX,CAAC,CAAED,cAAc,CAAC,CACpB,CAAC,IAAM,IAAIF,iBAAiB,CAACK,OAAO,EAAIJ,oBAAoB,CAAE,CAC5DJ,QAAQ,CAAC,yDAAyD,CAAC,CACrE,CACF,CAAC,CAEDY,EAAE,CAACmB,OAAO,CAAId,KAAK,EAAK,CACtBH,OAAO,CAACf,KAAK,CAAC,kBAAkB,CAAEkB,KAAK,CAAC,CACxCjB,QAAQ,CAAC,2BAA2B,CAAC,CACvC,CAAC,CACH,CAAE,MAAOyB,GAAG,CAAE,CACZX,OAAO,CAACf,KAAK,CAAC,wCAAwC,CAAE0B,GAAG,CAAC,CAC5DzB,QAAQ,CAAC,6BAA6B,CAAC,CACzC,CACF,CAAC,CAAE,CAACR,GAAG,CAAC,CAAC,CAET,KAAM,CAAAwC,UAAU,CAAG1C,WAAW,CAAC,IAAM,CACnC,GAAIY,mBAAmB,CAACM,OAAO,CAAE,CAC/ByB,YAAY,CAAC/B,mBAAmB,CAACM,OAAO,CAAC,CACzCN,mBAAmB,CAACM,OAAO,CAAG,IAAI,CACpC,CAEA,GAAIP,KAAK,CAACO,OAAO,CAAE,CACjBP,KAAK,CAACO,OAAO,CAAC0B,KAAK,CAAC,IAAI,CAAE,mBAAmB,CAAC,CAC9CjC,KAAK,CAACO,OAAO,CAAG,IAAI,CACtB,CAEAd,cAAc,CAAC,KAAK,CAAC,CACrBE,aAAa,CAAC,EAAE,CAAC,CACjBI,QAAQ,CAAC,IAAI,CAAC,CACdG,iBAAiB,CAACK,OAAO,CAAG,CAAC,CAC/B,CAAC,CAAE,EAAE,CAAC,CAEN,KAAM,CAAA2B,SAAS,CAAG7C,WAAW,CAAE8C,SAAiB,EAAK,KAAAC,eAAA,CACnD,GAAI,EAAAA,eAAA,CAAApC,KAAK,CAACO,OAAO,UAAA6B,eAAA,iBAAbA,eAAA,CAAe5B,UAAU,IAAKC,SAAS,CAACC,IAAI,CAAE,CAChD,GAAI,CACF,KAAM,CAAAO,OAAO,CAAG,CACdI,IAAI,CAAE,OAAO,CACbD,IAAI,CAAEe,SACR,CAAC,CACDnC,KAAK,CAACO,OAAO,CAAC8B,IAAI,CAACnB,IAAI,CAACoB,SAAS,CAACrB,OAAO,CAAC,CAAC,CAC7C,CAAE,MAAOO,GAAG,CAAE,CACZX,OAAO,CAACf,KAAK,CAAC,uBAAuB,CAAE0B,GAAG,CAAC,CAC3CzB,QAAQ,CAAC,gCAAgC,CAAC,CAC5C,CACF,CAAC,IAAM,CACLc,OAAO,CAAC0B,IAAI,CAAC,4BAA4B,CAAC,CAC1CxC,QAAQ,CAAC,yBAAyB,CAAC,CACrC,CACF,CAAC,CAAE,EAAE,CAAC,CAEN,KAAM,CAAAyC,eAAe,CAAGnD,WAAW,CAAC,IAAM,CACxCM,aAAa,CAAC,EAAE,CAAC,CACjBI,QAAQ,CAAC,IAAI,CAAC,CAChB,CAAC,CAAE,EAAE,CAAC,CAEN;AACAZ,SAAS,CAAC,IAAM,CACdkB,OAAO,CAAC,CAAC,CAET,MAAO,IAAM,CACX0B,UAAU,CAAC,CAAC,CACd,CAAC,CACH,CAAC,CAAE,CAAC1B,OAAO,CAAE0B,UAAU,CAAC,CAAC,CAEzB;AACA5C,SAAS,CAAC,IAAM,CACd,MAAO,IAAM,CACX,GAAIc,mBAAmB,CAACM,OAAO,CAAE,CAC/ByB,YAAY,CAAC/B,mBAAmB,CAACM,OAAO,CAAC,CAC3C,CACF,CAAC,CACH,CAAC,CAAE,EAAE,CAAC,CAEN,MAAO,CACLf,WAAW,CACXE,UAAU,CACVE,kBAAkB,CAClBE,KAAK,CACLoC,SAAS,CACT7B,OAAO,CACP0B,UAAU,CACVS,eACF,CAAC,CACH,CAAC,CAED,cAAe,CAAAlD,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}