{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nexport const useWebSocket = url => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const [detections, setDetections] = useState([]);\n  const [lastProcessingTime, setLastProcessingTime] = useState(0);\n  const [error, setError] = useState(null);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttempts = useRef(0);\n  const maxReconnectAttempts = 5;\n  const reconnectDelay = 3000;\n  const connect = useCallback(() => {\n    var _wsRef$current;\n    if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.OPEN) {\n      return;\n    }\n    try {\n      const ws = new WebSocket(url);\n      wsRef.current = ws;\n      ws.onopen = () => {\n        console.log('WebSocket connected');\n        setIsConnected(true);\n        setError(null);\n        reconnectAttempts.current = 0;\n      };\n      ws.onmessage = event => {\n        try {\n          // Validate that event.data exists and is not empty\n          if (!event.data || event.data.trim() === '') {\n            console.warn('Received empty WebSocket message');\n            return;\n          }\n\n          // Validate that event.data is a string\n          if (typeof event.data !== 'string') {\n            console.warn('Received non-string WebSocket message:', typeof event.data);\n            return;\n          }\n          const message = JSON.parse(event.data);\n\n          // Validate message structure\n          if (!message || typeof message !== 'object' || !message.type) {\n            console.warn('Received invalid message structure:', message);\n            return;\n          }\n          switch (message.type) {\n            case 'detection':\n              if (message.detections && Array.isArray(message.detections)) {\n                setDetections(message.detections);\n                if (typeof message.processing_time === 'number') {\n                  setLastProcessingTime(message.processing_time);\n                }\n              }\n              break;\n            case 'error':\n              console.error('WebSocket error message:', message.message);\n              setError(message.message || 'Unknown error occurred');\n              break;\n            case 'status':\n              console.log('WebSocket status:', message.status);\n              break;\n            case 'pong':\n              // Handle pong response\n              console.log('Received pong from server');\n              break;\n            default:\n              console.log('Unknown message type:', message.type, message);\n          }\n        } catch (err) {\n          var _event$data;\n          console.error('Failed to parse WebSocket message:', {\n            error: err,\n            rawData: event.data,\n            dataType: typeof event.data,\n            dataLength: (_event$data = event.data) === null || _event$data === void 0 ? void 0 : _event$data.length\n          });\n          setError('Failed to parse server response');\n        }\n      };\n      ws.onclose = event => {\n        console.log('WebSocket disconnected:', event.code, event.reason);\n        setIsConnected(false);\n        wsRef.current = null;\n\n        // Attempt to reconnect if not a manual disconnect\n        if (event.code !== 1000 && reconnectAttempts.current < maxReconnectAttempts) {\n          reconnectAttempts.current++;\n          console.log(`Attempting to reconnect (${reconnectAttempts.current}/${maxReconnectAttempts})...`);\n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, reconnectDelay);\n        } else if (reconnectAttempts.current >= maxReconnectAttempts) {\n          setError('Failed to reconnect to server. Please refresh the page.');\n        }\n      };\n      ws.onerror = event => {\n        console.error('WebSocket error:', event);\n        setError('Connection error occurred');\n      };\n    } catch (err) {\n      console.error('Failed to create WebSocket connection:', err);\n      setError('Failed to connect to server');\n    }\n  }, [url]);\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    if (wsRef.current) {\n      wsRef.current.close(1000, 'Manual disconnect');\n      wsRef.current = null;\n    }\n    setIsConnected(false);\n    setDetections([]);\n    setError(null);\n    reconnectAttempts.current = 0;\n  }, []);\n  const sendFrame = useCallback(imageData => {\n    var _wsRef$current2;\n    if (((_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.readyState) === WebSocket.OPEN) {\n      try {\n        const message = {\n          type: 'frame',\n          image: imageData\n        };\n        wsRef.current.send(JSON.stringify(message));\n      } catch (err) {\n        console.error('Failed to send frame:', err);\n        setError('Failed to send frame to server');\n      }\n    } else {\n      console.warn('WebSocket is not connected');\n      setError('Not connected to server');\n    }\n  }, []);\n  const clearDetections = useCallback(() => {\n    setDetections([]);\n    setError(null);\n  }, []);\n\n  // Auto-connect on mount\n  useEffect(() => {\n    connect();\n    return () => {\n      disconnect();\n    };\n  }, [connect, disconnect]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n    };\n  }, []);\n  return {\n    isConnected,\n    detections,\n    lastProcessingTime,\n    error,\n    sendFrame,\n    connect,\n    disconnect,\n    clearDetections\n  };\n};\n_s(useWebSocket, \"CuKS4dM2JxmNeK3cBqJbomrVQ7Y=\");\nexport default useWebSocket;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useWebSocket","url","_s","isConnected","setIsConnected","detections","setDetections","lastProcessingTime","setLastProcessingTime","error","setError","wsRef","reconnectTimeoutRef","reconnectAttempts","maxReconnectAttempts","reconnectDelay","connect","_wsRef$current","current","readyState","WebSocket","OPEN","ws","onopen","console","log","onmessage","event","data","trim","warn","message","JSON","parse","type","Array","isArray","processing_time","status","err","_event$data","rawData","dataType","dataLength","length","onclose","code","reason","setTimeout","onerror","disconnect","clearTimeout","close","sendFrame","imageData","_wsRef$current2","image","send","stringify","clearDetections"],"sources":["C:/Users/Asus/OneDrive/Desktop/card/frontend/src/hooks/useWebSocket.ts"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\n\ninterface Detection {\n  rank: string;\n  suit: string;\n  confidence: number;\n  bbox: [number, number, number, number];\n  card_name?: string;\n}\n\ninterface WebSocketMessage {\n  type: 'frame' | 'detection' | 'error' | 'status' | 'pong';\n  data?: any;\n  detections?: Detection[];\n  message?: string;\n  status?: string;\n  processing_time?: number;\n}\n\ninterface UseWebSocketReturn {\n  isConnected: boolean;\n  detections: Detection[];\n  lastProcessingTime: number;\n  error: string | null;\n  sendFrame: (imageData: string) => void;\n  connect: () => void;\n  disconnect: () => void;\n  clearDetections: () => void;\n}\n\nexport const useWebSocket = (url: string): UseWebSocketReturn => {\n  const [isConnected, setIsConnected] = useState(false);\n  const [detections, setDetections] = useState<Detection[]>([]);\n  const [lastProcessingTime, setLastProcessingTime] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const reconnectAttempts = useRef(0);\n  const maxReconnectAttempts = 5;\n  const reconnectDelay = 3000;\n\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return;\n    }\n\n    try {\n      const ws = new WebSocket(url);\n      wsRef.current = ws;\n\n      ws.onopen = () => {\n        console.log('WebSocket connected');\n        setIsConnected(true);\n        setError(null);\n        reconnectAttempts.current = 0;\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          // Validate that event.data exists and is not empty\n          if (!event.data || event.data.trim() === '') {\n            console.warn('Received empty WebSocket message');\n            return;\n          }\n\n          // Validate that event.data is a string\n          if (typeof event.data !== 'string') {\n            console.warn('Received non-string WebSocket message:', typeof event.data);\n            return;\n          }\n\n          const message: WebSocketMessage = JSON.parse(event.data);\n          \n          // Validate message structure\n          if (!message || typeof message !== 'object' || !message.type) {\n            console.warn('Received invalid message structure:', message);\n            return;\n          }\n          \n          switch (message.type) {\n            case 'detection':\n              if (message.detections && Array.isArray(message.detections)) {\n                setDetections(message.detections);\n                if (typeof message.processing_time === 'number') {\n                  setLastProcessingTime(message.processing_time);\n                }\n              }\n              break;\n              \n            case 'error':\n              console.error('WebSocket error message:', message.message);\n              setError(message.message || 'Unknown error occurred');\n              break;\n              \n            case 'status':\n              console.log('WebSocket status:', message.status);\n              break;\n              \n            case 'pong':\n              // Handle pong response\n              console.log('Received pong from server');\n              break;\n              \n            default:\n              console.log('Unknown message type:', message.type, message);\n          }\n        } catch (err) {\n          console.error('Failed to parse WebSocket message:', {\n            error: err,\n            rawData: event.data,\n            dataType: typeof event.data,\n            dataLength: event.data?.length\n          });\n          setError('Failed to parse server response');\n        }\n      };\n\n      ws.onclose = (event) => {\n        console.log('WebSocket disconnected:', event.code, event.reason);\n        setIsConnected(false);\n        wsRef.current = null;\n        \n        // Attempt to reconnect if not a manual disconnect\n        if (event.code !== 1000 && reconnectAttempts.current < maxReconnectAttempts) {\n          reconnectAttempts.current++;\n          console.log(`Attempting to reconnect (${reconnectAttempts.current}/${maxReconnectAttempts})...`);\n          \n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, reconnectDelay);\n        } else if (reconnectAttempts.current >= maxReconnectAttempts) {\n          setError('Failed to reconnect to server. Please refresh the page.');\n        }\n      };\n\n      ws.onerror = (event) => {\n        console.error('WebSocket error:', event);\n        setError('Connection error occurred');\n      };\n    } catch (err) {\n      console.error('Failed to create WebSocket connection:', err);\n      setError('Failed to connect to server');\n    }\n  }, [url]);\n\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    \n    if (wsRef.current) {\n      wsRef.current.close(1000, 'Manual disconnect');\n      wsRef.current = null;\n    }\n    \n    setIsConnected(false);\n    setDetections([]);\n    setError(null);\n    reconnectAttempts.current = 0;\n  }, []);\n\n  const sendFrame = useCallback((imageData: string) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      try {\n        const message = {\n          type: 'frame',\n          image: imageData\n        };\n        wsRef.current.send(JSON.stringify(message));\n      } catch (err) {\n        console.error('Failed to send frame:', err);\n        setError('Failed to send frame to server');\n      }\n    } else {\n      console.warn('WebSocket is not connected');\n      setError('Not connected to server');\n    }\n  }, []);\n\n  const clearDetections = useCallback(() => {\n    setDetections([]);\n    setError(null);\n  }, []);\n\n  // Auto-connect on mount\n  useEffect(() => {\n    connect();\n    \n    return () => {\n      disconnect();\n    };\n  }, [connect, disconnect]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    isConnected,\n    detections,\n    lastProcessingTime,\n    error,\n    sendFrame,\n    connect,\n    disconnect,\n    clearDetections\n  };\n};\n\nexport default useWebSocket;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}