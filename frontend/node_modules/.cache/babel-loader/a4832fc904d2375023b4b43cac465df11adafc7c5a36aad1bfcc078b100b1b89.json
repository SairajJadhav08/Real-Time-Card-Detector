{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nexport const useWebSocket = url => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const [detections, setDetections] = useState([]);\n  const [lastProcessingTime, setLastProcessingTime] = useState(0);\n  const [error, setError] = useState(null);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttempts = useRef(0);\n  const maxReconnectAttempts = 5;\n  const reconnectDelay = 3000;\n  const connect = useCallback(() => {\n    var _wsRef$current;\n    if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.OPEN) {\n      return;\n    }\n    try {\n      const ws = new WebSocket(url);\n      wsRef.current = ws;\n      ws.onopen = () => {\n        console.log('WebSocket connected');\n        setIsConnected(true);\n        setError(null);\n        reconnectAttempts.current = 0;\n      };\n      ws.onmessage = event => {\n        try {\n          const message = JSON.parse(event.data);\n          switch (message.type) {\n            case 'detection':\n              if (message.detections) {\n                setDetections(message.detections);\n                if (message.processing_time) {\n                  setLastProcessingTime(message.processing_time);\n                }\n              }\n              break;\n            case 'error':\n              console.error('WebSocket error:', message.message);\n              setError(message.message || 'Unknown error occurred');\n              break;\n            case 'status':\n              console.log('WebSocket status:', message.status);\n              break;\n            default:\n              console.log('Unknown message type:', message.type);\n          }\n        } catch (err) {\n          console.error('Failed to parse WebSocket message:', err);\n          setError('Failed to parse server response');\n        }\n      };\n      ws.onclose = event => {\n        console.log('WebSocket disconnected:', event.code, event.reason);\n        setIsConnected(false);\n        wsRef.current = null;\n\n        // Attempt to reconnect if not a manual disconnect\n        if (event.code !== 1000 && reconnectAttempts.current < maxReconnectAttempts) {\n          reconnectAttempts.current++;\n          console.log(`Attempting to reconnect (${reconnectAttempts.current}/${maxReconnectAttempts})...`);\n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, reconnectDelay);\n        } else if (reconnectAttempts.current >= maxReconnectAttempts) {\n          setError('Failed to reconnect to server. Please refresh the page.');\n        }\n      };\n      ws.onerror = event => {\n        console.error('WebSocket error:', event);\n        setError('Connection error occurred');\n      };\n    } catch (err) {\n      console.error('Failed to create WebSocket connection:', err);\n      setError('Failed to connect to server');\n    }\n  }, [url]);\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    if (wsRef.current) {\n      wsRef.current.close(1000, 'Manual disconnect');\n      wsRef.current = null;\n    }\n    setIsConnected(false);\n    setDetections([]);\n    setError(null);\n    reconnectAttempts.current = 0;\n  }, []);\n  const sendFrame = useCallback(imageData => {\n    var _wsRef$current2;\n    if (((_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.readyState) === WebSocket.OPEN) {\n      try {\n        const message = {\n          type: 'frame',\n          data: imageData\n        };\n        wsRef.current.send(JSON.stringify(message));\n      } catch (err) {\n        console.error('Failed to send frame:', err);\n        setError('Failed to send frame to server');\n      }\n    } else {\n      console.warn('WebSocket is not connected');\n      setError('Not connected to server');\n    }\n  }, []);\n  const clearDetections = useCallback(() => {\n    setDetections([]);\n    setError(null);\n  }, []);\n\n  // Auto-connect on mount\n  useEffect(() => {\n    connect();\n    return () => {\n      disconnect();\n    };\n  }, [connect, disconnect]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n    };\n  }, []);\n  return {\n    isConnected,\n    detections,\n    lastProcessingTime,\n    error,\n    sendFrame,\n    connect,\n    disconnect,\n    clearDetections\n  };\n};\n_s(useWebSocket, \"CuKS4dM2JxmNeK3cBqJbomrVQ7Y=\");\nexport default useWebSocket;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useWebSocket","url","_s","isConnected","setIsConnected","detections","setDetections","lastProcessingTime","setLastProcessingTime","error","setError","wsRef","reconnectTimeoutRef","reconnectAttempts","maxReconnectAttempts","reconnectDelay","connect","_wsRef$current","current","readyState","WebSocket","OPEN","ws","onopen","console","log","onmessage","event","message","JSON","parse","data","type","processing_time","status","err","onclose","code","reason","setTimeout","onerror","disconnect","clearTimeout","close","sendFrame","imageData","_wsRef$current2","send","stringify","warn","clearDetections"],"sources":["C:/Users/Asus/OneDrive/Desktop/card/frontend/src/hooks/useWebSocket.ts"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\n\ninterface Detection {\n  rank: string;\n  suit: string;\n  confidence: number;\n  bbox: [number, number, number, number];\n  card_name?: string;\n}\n\ninterface WebSocketMessage {\n  type: 'frame' | 'detection' | 'error' | 'status';\n  data?: any;\n  detections?: Detection[];\n  message?: string;\n  status?: string;\n  processing_time?: number;\n}\n\ninterface UseWebSocketReturn {\n  isConnected: boolean;\n  detections: Detection[];\n  lastProcessingTime: number;\n  error: string | null;\n  sendFrame: (imageData: string) => void;\n  connect: () => void;\n  disconnect: () => void;\n  clearDetections: () => void;\n}\n\nexport const useWebSocket = (url: string): UseWebSocketReturn => {\n  const [isConnected, setIsConnected] = useState(false);\n  const [detections, setDetections] = useState<Detection[]>([]);\n  const [lastProcessingTime, setLastProcessingTime] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const reconnectAttempts = useRef(0);\n  const maxReconnectAttempts = 5;\n  const reconnectDelay = 3000;\n\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return;\n    }\n\n    try {\n      const ws = new WebSocket(url);\n      wsRef.current = ws;\n\n      ws.onopen = () => {\n        console.log('WebSocket connected');\n        setIsConnected(true);\n        setError(null);\n        reconnectAttempts.current = 0;\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const message: WebSocketMessage = JSON.parse(event.data);\n          \n          switch (message.type) {\n            case 'detection':\n              if (message.detections) {\n                setDetections(message.detections);\n                if (message.processing_time) {\n                  setLastProcessingTime(message.processing_time);\n                }\n              }\n              break;\n              \n            case 'error':\n              console.error('WebSocket error:', message.message);\n              setError(message.message || 'Unknown error occurred');\n              break;\n              \n            case 'status':\n              console.log('WebSocket status:', message.status);\n              break;\n              \n            default:\n              console.log('Unknown message type:', message.type);\n          }\n        } catch (err) {\n          console.error('Failed to parse WebSocket message:', err);\n          setError('Failed to parse server response');\n        }\n      };\n\n      ws.onclose = (event) => {\n        console.log('WebSocket disconnected:', event.code, event.reason);\n        setIsConnected(false);\n        wsRef.current = null;\n        \n        // Attempt to reconnect if not a manual disconnect\n        if (event.code !== 1000 && reconnectAttempts.current < maxReconnectAttempts) {\n          reconnectAttempts.current++;\n          console.log(`Attempting to reconnect (${reconnectAttempts.current}/${maxReconnectAttempts})...`);\n          \n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, reconnectDelay);\n        } else if (reconnectAttempts.current >= maxReconnectAttempts) {\n          setError('Failed to reconnect to server. Please refresh the page.');\n        }\n      };\n\n      ws.onerror = (event) => {\n        console.error('WebSocket error:', event);\n        setError('Connection error occurred');\n      };\n    } catch (err) {\n      console.error('Failed to create WebSocket connection:', err);\n      setError('Failed to connect to server');\n    }\n  }, [url]);\n\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    \n    if (wsRef.current) {\n      wsRef.current.close(1000, 'Manual disconnect');\n      wsRef.current = null;\n    }\n    \n    setIsConnected(false);\n    setDetections([]);\n    setError(null);\n    reconnectAttempts.current = 0;\n  }, []);\n\n  const sendFrame = useCallback((imageData: string) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      try {\n        const message = {\n          type: 'frame',\n          data: imageData\n        };\n        wsRef.current.send(JSON.stringify(message));\n      } catch (err) {\n        console.error('Failed to send frame:', err);\n        setError('Failed to send frame to server');\n      }\n    } else {\n      console.warn('WebSocket is not connected');\n      setError('Not connected to server');\n    }\n  }, []);\n\n  const clearDetections = useCallback(() => {\n    setDetections([]);\n    setError(null);\n  }, []);\n\n  // Auto-connect on mount\n  useEffect(() => {\n    connect();\n    \n    return () => {\n      disconnect();\n    };\n  }, [connect, disconnect]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    isConnected,\n    detections,\n    lastProcessingTime,\n    error,\n    sendFrame,\n    connect,\n    disconnect,\n    clearDetections\n  };\n};\n\nexport default useWebSocket;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}